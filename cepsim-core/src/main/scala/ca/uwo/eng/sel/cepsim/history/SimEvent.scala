package ca.uwo.eng.sel.cepsim.history

import ca.uwo.eng.sel.cepsim.query.{EventConsumer, EventProducer, Vertex, WindowedOperator}

/**
  * Trait that represents an important simulation event. These events are used to compose the
  * execution history and as input to metrics calculation. A simulation event is different from a CEP event,
  * as it is an internal class used to represent what happened during a simulation.
  */
trait SimEvent extends Ordered[SimEvent] {

  /** Vertex that originated the event. */
  def v: Vertex

  /** Number of events. The specific meaning of this number depends on the type of event. */
  def quantity: Double

  /** Start timestamp. */
  def from: Double

  /** End timestamp. */
  def to: Double

  /** Timestamp of the event. By default, the end timestamp is considered as the simulation event timestamp. */
  def at: Double = to


  def compare(that: SimEvent): Int = {
    var comp = this.from.compare(that.from)
    if (comp == 0) comp = this.to.compare(that.to)
    if (comp == 0) comp = this.v.compare(that.v)

    comp
  }

}

/**
  * Represents events generated by a Generator associated with an EventProducer.
  *
  * @param v Event Producer.
  * @param from Start timestamp.
  * @param to Final timestamp.
  * @param quantity Number of events generated.
  */
case class Generated (val v: EventProducer, val from: Double, val to: Double, val quantity: Double) extends SimEvent


/**
  * Represents events produced (emit) by an OutputVertex (EventProducer or any Operator).
  *
  * @param v Vertex emitting the events.
  * @param from Start timestamp.
  * @param to Final timestamp.
  * @param quantity Number of produced events.
  * @param processed Number of events consumed from each vertex predecessor in order to emit the events. If
  *                  the vertex is an EventProducer, then it does not have predecessors and this map is empty.
  */
case class Produced(val v: Vertex, val from: Double, val to: Double, val quantity: Double,
                     val processed: Map[Vertex, Double] = Map.empty) extends SimEvent


/**
  * Represents events produced by a WindowedOperator. It is a different class than Produced because it has an
  * extra attribute containing the window slot on which the production has happened. Additionally, this class
  * does not have the <code>processed</code> attribute because we assume that all events coming from
  * the operator predecessors have been accumulated before (and therefore, it had been considered by the
  * corresponding WindowAccumulated simulation event).
  *
  * @param v WindowedOperator emitting the events.
  * @param from Start timestamp.
  * @param to Final timestamp.
  * @param quantity Number of produced events.
  * @param slot Window slot number.
  */
case class WindowProduced(val v: WindowedOperator, val from: Double, val to: Double,
                          val quantity: Double, val slot: Int) extends SimEvent

/**
  * Represents events accumulated by a WindowedOperator.
  *
  * @param v WindowedOperator accumulating the events.
  * @param from Start timestamp.
  * @param to Final timestamp.
  * @param slot Slot number on which events have been accumulated.
  * @param processed Number of events consumed from each vertex predecessor and accumulated by the operator.
  */
case class WindowAccumulated(val v: WindowedOperator, val from: Double, val to: Double, val slot: Int,
                             val processed: Map[Vertex, Double] = Map.empty) extends SimEvent {

  /**
    * Quantity represents the number of accumulated events. It does not need to be informed when creating
    * an object because it is assumed that all events consumed from predecessors are accumulated.
    */
  val quantity: Double = Vertex.sumOfValues(processed)
}

/**
  * Represents events consumed by an EventConsumer.
  *
  * @param v EventConsumer consuming the events.
  * @param from Start timestamp.
  * @param to Final timestamp.
  * @param quantity Number of events consumed.
  * @param processed Number of events consumed from each vertex predecessor in order to emit the events.
  */
case class Consumed (val v: EventConsumer, val from: Double, val to: Double, val quantity: Double,
                     val processed: Map[Vertex, Double]) extends SimEvent

