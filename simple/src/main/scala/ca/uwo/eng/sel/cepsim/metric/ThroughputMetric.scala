package ca.uwo.eng.sel.cepsim.metric

import ca.uwo.eng.sel.cepsim.query.{EventConsumer, EventProducer, Query}

import scala.concurrent.duration.{Duration, SECONDS}


/** Calculates the throughput metric. */
object ThroughputMetric extends Metric {

  /**
    * Calculate the throughput (in events / second).
    * @param q Query from which the throughput should be calculated.
    * @param totalTime The total execution time of this query.
    * @return Query throughput in ev
    */
  def calculate(q: Query, totalTime: Duration): Double = {

    val pWeights = producersWeight(q)

    // for each consumer, it is estimated the total number of events that needs to be generated by
    // each producer (that results in the number of consumed events). Then, we sum everything
    val totalEvents = q.consumers.foldLeft(0.0)((acc, consumer) => acc + totalEvent(q, pWeights, consumer))

    // divide by the time
    totalEvents / totalTime.toUnit(SECONDS)
  }


  /**
    * Estimate the total number of events that needs to be generated by all producers so that the
    * output events could be created.
    *
    * @param q Query to which the consumer belongs.
    * @param producerWeights Weight assigned to each producer.
    * @param c Consumer on which the estimation is executed.
    * @return An estimation of the total number of events generated by the producers.
    */
  private def totalEvent(q: Query, producerWeights: Map[EventProducer, Double], c: EventConsumer): Double = {
    eventsPerProducer(q, producerWeights, c, c.outputQueue).foldLeft(0.0)((acc, elem) => acc + elem._2)
  }






}
