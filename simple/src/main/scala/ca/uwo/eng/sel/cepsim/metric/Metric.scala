package ca.uwo.eng.sel.cepsim.metric

import ca.uwo.eng.sel.cepsim.query.{EventProducer, EventConsumer, Query}

/** Super class of all metrics. Defines common methods used by metric objects. */
class Metric {
  /**
   * Estimate the number of events that needs to be generated by each producer so that the
   * output events could be created.
   *
   * @param q Query to which the consumer belongs.
   * @param c Consumer on which the estimation is executed.
   * @return An estimation of the total number of events generated by the producers.
   */
  def eventsPerProducer(q: Query, c: EventConsumer): Map[EventProducer, Double] = {
    val pWeights = producersWeight(q)
    eventsPerProducer(q, pWeights, c)
  }

  /**
   * Estimate the number of events that needs to be generated by each producer so that the
   * output events could be created.
   *
   * @param q Query to which the consumer belongs.
   * @param producerWeights Weight assigned to each producer.
   * @param c Consumer on which the estimation is executed.
   * @return An estimation of the total number of events generated by the producers.
   */
  protected def eventsPerProducer(q: Query, producerWeights: Map[EventProducer, Double], c: EventConsumer):
    Map[EventProducer, Double] = {

    // find all paths from the consumer to all producers
    val paths = q.pathsToProducers(c)

    // for each path, all the selectivities are multiplied (including the producer "selectivity")
    val pathWeights = paths.map{(p) =>
      (p.producer, p.edges.foldLeft(1.0)((acc, edge) => acc * edge.selectivity) * producerWeights(p.producer))
    }

    // then, the weights of paths from the same producer are summed
    val totalWeightsPerProducer: Map[EventProducer, Double] = pathWeights.groupBy(_._1).mapValues {
      // each value is a list of pairs (producer, weight) from the same producer
      (list) => list.foldLeft(0.0)((acc, listElem) => acc + listElem._2)
    }

    // all weights are summed
    val totalWeight = totalWeightsPerProducer.foldLeft(0.0)((acc, elem) => acc + elem._2)

    // total events are estimated
    val totalEvents = c.outputQueue / totalWeight

    // and finally, the total number of events is distributed among the producers
    producerWeights.mapValues((v) => v * totalEvents)

  }

  /**
   * Estimate the weight of each producer relative to all producers.
   * @param q Query from which the estimation should be done.
   * @return Map of each event producer to its weight.
   */
  protected def producersWeight(q: Query): Map[EventProducer, Double] = {
    val producers = q.producers

    // sum of all producers average
    val totalProducersWeight = producers.foldLeft(0.0)((acc, producer) => acc + producer.generator.average)

    // proportion of each producer to the sum
    producers.map((p) => (p, p.generator.average / totalProducersWeight)).toMap[EventProducer, Double]
  }

}
